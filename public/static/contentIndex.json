{"Decorator-Pattern":{"title":"Decorator Pattern","links":[],"tags":[],"content":"Comming Soon"},"Observer-Pattern":{"title":"Observer Pattern","links":[],"tags":[],"content":"Comming Soon"},"Strategy-Pattern":{"title":"Strategy Pattern","links":["tags/behavioral"],"tags":["behavioral"],"content":"behavioral\nDefinition\nIt defines a family of algorithms, encapsulates each one, and makes them interchangeable. The Strategy Pattern allows algorithms to vary independently from the clients that use them.\n\nReal World Analogy - 1\nConsider creating a Duck application with different types of ducks that can quack and fly. A simple approach would be to create a base class called Duck with methods like fly() and quack(), then implement these methods in specific duck types.\n---\ntitle: Brute Force Approach\n---\nclassDiagram\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        +fly() void\n        +quack() void\n    }\n    class MallardDuck{\n        +fly() void\n        +quack() void\n    }\n    class RubberDuck{\n        +fly() void  \n        +quack() void\n    }\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\n\n\n                  \n                  What is Wrong With These Approach ? \n                  \n                \n\nYou have implemented a base class called Duck, where methods like fly() and quack() are already defined. For example, the base class Duck has a default implementation of flying. However, in the case of a RubberDuck class, the duck cannot quack or fly.\nTo modify this behavior, you would need to override the fly() and quack() methods, which becomes inefficient when dealing with dozens of duck types. To address this issue, you can use the Strategy Pattern.\n\n\nLet’s see the Implementation via Strategy Pattern:\n---\ntitle: Strategy Pattern\n---\n\nclassDiagram\n\n    class FlyBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +fly() void\n    }\n\n    class QuackBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +quack() void\n    }\n\n    class FlyWithWings{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- FlyWithWings\n\n    class NoFly{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- NoFly\n\n    class Quack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- Quack\n\n    class MuteQuack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- MuteQuack\n\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        -flyBehavior : FlyBehavior\n        -quackBehavior : QuackBehavior\n\n        +performFly() void\n        +performQuack() void\n        +setFlyBehavior(fb : FlyBehavior) void\n        +setQuackBehavior(qb : QuackBehavior) void\n    }\n    FlyBehavior *-- Duck : has a\n    QuackBehavior *-- Duck : has a\n\n    class MallardDuck{\n    }\n\n    class RubberDuck{\n    }\n\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\nHere, we create two interfaces:\n\nFlyBehavior, which defines different flying behaviors.\nQuackBehavior, which defines different quacking behaviors.\n\nBy implementing these interfaces, you can create new behaviors independently. The abstract base class Duck uses these interfaces in the constructor, allowing you to dynamically change behaviors or even create a new duck type by passing specific or custom behaviors.\nNow, instead of modifying the base Duck class for every new type, you can simply create new behavior implementations and plug them in—making the system more flexible and scalable!\n\nCode in Java\nBelow is the Code for the above Strategy Pattern we discussed over Here.\n// Strategy Design Pattern Example: Ducks with Flying and Quacking Behaviors\n \npublic interface FlyBehavior {\n  // Interface defining the fly behavior contract\n  void fly();\n}\n \npublic class FlyWithWings implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can Fly&quot;);\n  }\n}\n \npublic class NoFly implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can&#039;t Fly&quot;);\n  }\n}\n \npublic interface QuackBehavior {\n  // Interface defining the quack behavior contract\n  void quack();\n}\n \npublic class Quack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Quacking....&quot;);\n  }\n}\n \npublic class MuteQuack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Mute Quacking&quot;);\n  }\n}\n \npublic class Squeak implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Squeak&quot;);\n  }\n}\n \npublic abstract class Duck {\n \n  private FlyBehavior _flyBehavior;\n  private QuackBehavior _quackBehavior;\n \n  // Constructor taking FlyBehavior and QuackBehavior arguments\n  // This allows for flexible behavior assignment at runtime\n  public Duck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    this._flyBehavior = flybehavior;\n    this._quackBehavior = quackBehavior;\n  }\n \n  public void quack() {\n    this._quackBehavior.quack();\n  }\n \n  public void fly() {\n    this._flyBehavior.fly();\n  }\n}\n \npublic class RubberDuck extends Duck {\n \n  public RubberDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class MallardDuck extends Duck {\n \n  public MallardDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class Index {\n  public static void main(String[] args) {\n    // The duck which is mute and cannot fly lets create that duck using rubber duck\n    System.out.println(&quot;======= Rubber Duck ======&quot;);\n    Duck rubberDuck = new RubberDuck(new NoFly(), new MuteQuack());\n    rubberDuck.fly();\n    rubberDuck.quack();\n \n    System.out.println();\n \n    // Mallard Duck\n    // Making the code feasible here we can change the behavior any time we want\n    // just need to change the constuctor call.\n    System.out.println(&quot;===== Mallard Duck =====&quot;);\n    Duck mallardDuck = new MallardDuck(new FlyWithWings(), new Squeak());\n    mallardDuck.fly();\n    mallardDuck.quack();\n  }\n}\n\nReal World Analogy - 2\nLet’s take another example: the Logging Framework.\nThis type of pattern is commonly used in logging frameworks, where you only pass the Logger Interface and call the log() method. The rest is handled by the class that implements the interface.\nSuppose an application uses an ILogger interface, which declares methods like LogInfo(), LogError(), and LogDebug(). The logger can have multiple implementations, such as ConsoleLogger, FileLogger, JsonLogger, or DBLogger.\nUsing this approach, there is no need to modify all the methods in the application when changing the type of logger. You only need to switch to a new logger by defining it in the configuration section, while the rest is managed by the respective logging class.\nBelow is the class diagram illustrating this approach.\n---\ntitle: Logger Framework Design\n---\n\nclassDiagram\n\tclass ILogger{\n\t\t&lt;&lt;interface&gt;&gt;\n\t\t+LogInf() void\n\t\t+LogError() void\n\t\t+LogWarning() void\n\t\t+LogDubug() void\n\t}\n\n\tclass FileLogger{\n\t\t+LogInf() void\n\t\t+LogError() void\n\t\t+LogWarning() void\n\t\t+LogDubug() void\n\t}\n\n\tclass ConsoleLogger{\n\t\t+LogInf() void\n\t\t+LogError() void\n\t\t+LogWarning() void\n\t\t+LogDubug() void\n\t}\n\n\tILogger &lt;|-- FileLogger\n\tILogger &lt;|-- ConsoleLogger\n\n\tclass Application{\n\t\t-logger ILogger \n\t\t+PerformOperation() void\n\t\t+KillProcess() void\n\t}\n\n\t\n\n"},"index":{"title":"Design Patterns","links":["tags/","Strategy-Pattern","Observer-Pattern"],"tags":[""],"content":"What is Design Pattern ?\nDesign patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.\nThree Main Patterns\n\nCreational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.\nStructural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.\nBehavioral patterns take care of effective communication and the assignment of responsibilities between objects.\n\n\n\n                  \n                  Prerequisite \n                  \n                \n\nMust have knowledge of OOPS (Object-Oriented Programming Principles) and Java. The design patterns are primarily based on OOPS concepts. The code in this tutorial is mainly written in Java and related frameworks.\nOOPS Concepts:\n\nInheritance\nAbstraction\nPolymorphism\nEncapsulation\n\n\n\nBefore diving into design patterns, it’s important to understand the SOLID Principles, Tightly Coupled Classes, and Loosely Coupled Classes. Additionally, some tips and tricks for writing clean code.\n\nTightly Coupled and Loosely Coupled Classes\nIn software design, coupling refers to the degree of dependency between two classes or modules. It determines how closely one class is connected to another.\n1. Tightly Coupled Classes\nDefinition: These classes are highly dependent on each other. Changes in one class often require changes in the other, making the system rigid and harder to maintain. These classes violates the Single Responsibility Principle which is the part of the SOLID Principle.\nExample :\nConsider a MessageService class that sends messages via Email, SMS, or other techniques. The implementation might look like the following code:\nclass MessageService {\n \n\tpublic static void sendMessage(string message){\n\t\t// Tightly Coupled on the email only\n\t\tEmailClient emailclient = new EmailClient();\n\t\temailclient.sendEmail(message);\n\t}\n\t\n}\nIn this code, you can see that the sendMessage method sends the message exclusively via Email. The EmailClient class is tightly coupled with this method. If you need to send messages using other providers (e.g., SMS or other techniques), you would have to create separate services for each provider. This approach is inefficient and leads to code repetition.\n2. Loosely Coupled Classes\nDefinition: These classes have minimal dependency on each other. They interact through interfaces or abstractions, making the system flexible, maintainable, and reusable.\nThese Approach Follows Dependency Inversion Principle which is again the part of the SOLID Principle.\nExample:\nIn the earlier example, the MessageService class was heavily dependent on EmailClient. In such cases, if you need to create another service, it becomes inefficient. We can avoid this dependency by passing the ProviderClient interface as a parameter to the sendMessage method. Then, we implement the ProviderClient interface for various provider services.\n \n// Interface to be implemented by various provider services\ninterface ProviderClient {\n    void send(String message, String to);\n}\n \n// Email Service implementing the ProviderClient interface\npublic class EmailClient implements ProviderClient {\n    public void send(String message, String to) {\n        // Code to send an email\n    } \n}\n \n// SMS Service implementing the ProviderClient interface\npublic class SMSClient implements ProviderClient {\n    public void send(String message, String to) {\n        // Code to send an SMS\n    }\n}\n \n// MessageService class using ProviderClient\nclass MessageService {\n    public static void sendMessage(ProviderClient client, String message, String to) {\n        client.send(message, to);\n    }\n}\n \nNow, you can add as many providers as needed, and MessageService will continue to work without being tightly coupled to EmailClient.\n\n SOLID Principles\nThe SOLID principles are five key object-oriented design principles that should be followed when creating a class structure. Let’s go through each principle one by one:\n1. Single Responsibility Principle (SRP)\nThis principle states that a class should have only one responsibility and, therefore, only one reason to change.\nExample:\nConsider a Book class that contains all the methods and variables related to a book. You should not include code related to a Student class or methods that are not relevant to the Book class.\n2. Open-Closed Principle (OCP)\nThis principle states that a class should be open for extension but closed for modification. Modification refers to changing the code of an existing class, while extension means adding new functionality without altering the existing code.\nExample:\nIf you have a well-tested and reliable class, modifying its code can introduce bugs and potential system crashes. Instead, you should extend the functionality using abstract classes or interfaces rather than modifying the tested code directly.\n3. Liskov Substitution Principle (LSP)\nThis principle states that subtypes of a base class must be substitutable without altering the correctness of the program.\nExample:\nConsider an abstract or base class Shape with a method to calculate the area. If you create a Rectangle class by inheriting from Shape, calling the area calculation method on a Rectangle object (using a Shape reference) should return the expected result without requiring changes to the base class.\n4. Interface Segregation Principle (ISP)\nThis principle states that a class should not be forced to implement interfaces it does not use. It is better to have multiple smaller, specific interfaces rather than a large, general-purpose interface.\nExample:\nConsider a Programmer class with methods like work(), eat(), test(), and assign(), all declared in an IEmployee interface. The problem arises when you introduce Manager and TeamLead classes—they require the assign() method, but it doesn’t belong in the Programmer class. To fix this, you can segregate the interfaces:\n\nCommon employee methods go in the IEmployee interface.\nManagement-related methods go in an IManage interface.\n\nThis way, only relevant methods are implemented by each class.\n5. Dependency Inversion Principle (DIP)\nThis principle states that high-level modules should not depend on low-level modules; instead, both should depend on abstractions (interfaces or abstract classes).\nExample:\nConsider an SQLManager class that performs CRUD operations. It has an ILogger interface for logging, which allows you to use different loggers like FileLogger, ConsoleLogger, or TableLogger. Since the SQLManager depends on the abstraction (ILogger) rather than a specific logging implementation, you can switch loggers without breaking the system.\n\nContents:\n\nStrategy Pattern\nObserver Pattern\n\n\n\n\n                  \n                  Note\n                  \n                \n\nAll the Patterns and code Examples are taken from the Book titled Head First Design Patterns\n\n"}}