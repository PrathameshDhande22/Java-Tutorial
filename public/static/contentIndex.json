{"Observer-Pattern":{"title":"Observer Pattern","links":[],"tags":[],"content":"Comming Soon"},"Strategy-Pattern":{"title":"Strategy Pattern","links":["tags/behavioral"],"tags":["behavioral"],"content":"behavioral\nDefinition\nIt Defines a family of algorithms encapsulates each one, and makes them interchangeable. Strategy Lets the algorithms vary independently from clients that use it.\n\nReal World Analogy\nConsider you are creating the Duck Application in which there are many types of Duck which may quack, fly. The Simple Approach would be just create the base class Duck and the method like fly, quack and implement it to other types of Duck.\n---\ntitle: Brute Force Approach\n---\nclassDiagram\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        +fly() void\n        +quack() void\n    }\n    class MallardDuck{\n        +fly() void\n        +quack() void\n    }\n    class RubberDuck{\n        +fly() void  \n        +quack() void\n    }\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\n\n\n                  \n                  What is Wrong With These Approach ? \n                  \n                \n\nYou have just implement the Base class as Duck in which the methods are also implemented. For Example the Base Class of the Duck has the implementation of the Fly Ducks. Then for RubberDuck Class, Duck cannot quack nor fly. To modify these behavior you need to rewrite the code again for the method fly and quack which is not feasible when it comes to dozens of duck. You need some approach to tackle these type of solution. Solution is Strategy Pattern.\n\n\nLet’s see the Implementation via Strategy Pattern:\n---\ntitle: Strategy Pattern\n---\n\nclassDiagram\n\n    class FlyBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +fly() void\n    }\n\n    class QuackBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +quack() void\n    }\n\n    class FlyWithWings{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- FlyWithWings\n\n    class NoFly{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- NoFly\n\n    class Quack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- Quack\n\n    class MuteQuack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- MuteQuack\n\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        -flyBehavior : FlyBehavior\n        -quackBehavior : QuackBehavior\n\n        +performFly() void\n        +performQuack() void\n        +setFlyBehavior(fb : FlyBehavior) void\n        +setQuackBehavior(qb : QuackBehavior) void\n    }\n    FlyBehavior *-- Duck : has a\n    QuackBehavior *-- Duck : has a\n\n    class MallardDuck{\n    }\n\n    class RubberDuck{\n    }\n\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\nHere we Created the Interface FlyBehavior and QuackBehavior which takes the method. By implementing these interface you can create new behavior. For Abstract Base Class Duck just make use of the Interface in the constructor means you can change the behaviour or even implement the new Duck by passing the Duck Behavior or Custom Behavior.\n\nCode in Java\nBelow is the Code for the above Strategy Pattern we discussed over Here.\n// Strategy Design Pattern Example: Ducks with Flying and Quacking Behaviors\n \npublic interface FlyBehavior {\n  // Interface defining the fly behavior contract\n  void fly();\n}\n \npublic class FlyWithWings implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can Fly&quot;);\n  }\n}\n \npublic class NoFly implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can&#039;t Fly&quot;);\n  }\n}\n \npublic interface QuackBehavior {\n  // Interface defining the quack behavior contract\n  void quack();\n}\n \npublic class Quack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Quacking....&quot;);\n  }\n}\n \npublic class MuteQuack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Mute Quacking&quot;);\n  }\n}\n \npublic class Squeak implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Squeak&quot;);\n  }\n}\n \npublic abstract class Duck {\n \n  private FlyBehavior _flyBehavior;\n  private QuackBehavior _quackBehavior;\n \n  // Constructor taking FlyBehavior and QuackBehavior arguments\n  // This allows for flexible behavior assignment at runtime\n  public Duck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    this._flyBehavior = flybehavior;\n    this._quackBehavior = quackBehavior;\n  }\n \n  public void quack() {\n    this._quackBehavior.quack();\n  }\n \n  public void fly() {\n    this._flyBehavior.fly();\n  }\n}\n \npublic class RubberDuck extends Duck {\n \n  public RubberDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class MallardDuck extends Duck {\n \n  public MallardDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class Index {\n  public static void main(String[] args) {\n    // The duck which is mute and cannot fly lets create that duck using rubber duck\n    System.out.println(&quot;======= Rubber Duck ======&quot;);\n    Duck rubberDuck = new RubberDuck(new NoFly(), new MuteQuack());\n    rubberDuck.fly();\n    rubberDuck.quack();\n \n    System.out.println();\n \n    // Mallard Duck\n    // Making the code feasible here we can change the behavior any time we want\n    // just need to change the constuctor call.\n    System.out.println(&quot;===== Mallard Duck =====&quot;);\n    Duck mallardDuck = new MallardDuck(new FlyWithWings(), new Squeak());\n    mallardDuck.fly();\n    mallardDuck.quack();\n  }\n}"},"index":{"title":"Java Design Patterns","links":["Strategy-Pattern","Observer-Pattern"],"tags":[],"content":"What is Design Pattern ?\nDesign patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.\nThree Main Patterns\n\nCreational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.\nStructural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.\nBehavioral patterns take care of effective communication and the assignment of responsibilities between objects.\n\n\nContents:\n\nStrategy Pattern\nObserver Pattern\n\n\n\n\n                  \n                  Note\n                  \n                \n\nAll the Patterns and code Examples are taken from the Book titled Head First Design Patterns\n\n"}}