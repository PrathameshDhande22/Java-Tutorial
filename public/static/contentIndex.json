{"Decorator-Pattern":{"title":"Decorator Pattern","links":[],"tags":[],"content":"Comming Soon"},"Observer-Pattern":{"title":"Observer Pattern","links":["tags/behavioral"],"tags":["behavioral"],"content":"behavioral\nDefinition\nIt Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically. Just like the Subscription, as long as you take the subscription you will get the updates, when you invoke the Subscription you will stop getting the updates or say the services.\n\nReal World Analogy\nWe are designing a Weather Application that consists of a WeatherData class. There are different types of displays attached to it, but currently, we only have CurrentConditionsDisplay.\nWhen the data inside the WeatherData class changes (i.e., temperature, pressure, and humidity), the updated data should be reflected on the display as well.\nThe application should be designed in such a way that when a new display is added, we don’t need to rewrite or modify the existing code.\nThe Observer Pattern is the ideal solution here. When the WeatherData class updates, it acts as a Subject, and its dependents (Observers/Subscribers) are notified automatically—as long as they are registered with the Subject.\n\nPublisher Notifies all the Subscriber\nDesign\n---\ntitle: Observer Pattern\n---\nclassDiagram\n    direction TB\n\n    class Subject {\n        &lt;&lt;interface&gt;&gt;\n        +registerObserver(o: Observer)\n        +removeObserver(o: Observer)\n        +notifyObserver()\n    }\n\n    class Observer {\n        &lt;&lt;interface&gt;&gt;\n        +update()\n    }\n\n    class DisplayElement {\n        &lt;&lt;interface&gt;&gt;\n        +display()\n    }\n\n    class WeatherData {\n        - List&lt;Observer&gt; observers\n        - float temperature\n        - float humidity\n        - float pressure\n        +registerObserver(o: Observer)\n        +removeObserver(o: Observer)\n        +notifyObserver()\n        +measurementsChanged()\n        +setMeasurements(temperature: float, pressure: float, humidity: float)\n        +getTemperature(): float\n        +getHumidity(): float\n        +getPressure(): float\n    }\n\n    class CurrentConditionDisplay {\n        - WeatherData weatherdata\n        +CurrentConditionDisplay(weatherdata: WeatherData)\n        +display()\n        +update()\n    }\n\n    class ForecastDisplay {\n        - WeatherData weatherdata\n        +ForecastDisplay(weatherdata: WeatherData)\n        +display()\n        +update()\n    }\n\n    Subject &lt;|.. WeatherData\n    Observer &lt;|.. CurrentConditionDisplay\n    Observer &lt;|.. ForecastDisplay\n    DisplayElement &lt;|.. CurrentConditionDisplay\n    DisplayElement &lt;|.. ForecastDisplay\n\n    WeatherData --&gt; Observer : &quot;maintains a list of&quot;\n    WeatherData --&gt; CurrentConditionDisplay : &quot;registers Observer&quot;\n    WeatherData --&gt; ForecastDisplay : &quot;registers Observer&quot;\n\n\nThe Design will look like the Above.\n\nCode in Java\n// These is the Subject\ninterface Subject {\n\tpublic void registerObserver(Observer o);\n\tpublic void removeObserver(Observer o);\n\tpublic void notifyObserver();\n}\n \ninterface Observer {\n\tpublic void update();\n}\n \ninterface DisplayElement {\n\tpublic void display();\n}\n \n// These is the main subject the observer register here to receive the updates to all the subscribed observer.\nclass WeatherData implements Subject {\n \n\tprivate List&lt;Observer&gt; observers = new ArrayList&lt;Observer&gt;();\n\tprivate float temperature = 0;\n\tprivate float humidity = 0;\n\tprivate float pressure = 0;\n \n\t// Register the Observer\n\t@Override\n\tpublic void registerObserver(Observer o) {\n\t\tobservers.add(o);\n\t}\n \n\t@Override\n\tpublic void removeObserver(Observer o) {\n\t\tobservers.remove(o);\n\t}\n \n\t// Notify all the observer which are subscribed\n\t@Override\n\tpublic void notifyObserver() {\n\t\tfor (Observer obs : observers) {\n\t\t\tobs.update();\n\t\t}\n\t}\n \n\t// when the measurements are changed notify&#039;s all the subscriber\n\tpublic void measurementsChanged() {\n\t\tthis.notifyObserver();\n\t}\n \n\t// Sets the measurements and displays the updates.\n\tpublic void setMeasurements(float temperature, float pressure, float humidity) {\n\t\tthis.humidity = humidity;\n\t\tthis.pressure = pressure;\n\t\tthis.temperature = temperature;\n\t\tthis.measurementsChanged();\n\t}\n \n\tpublic float getTemperature() {\n\t\treturn temperature;\n\t}\n \n\tpublic float getHumidity() {\n\t\treturn humidity;\n\t}\n \n\tpublic float getPressure() {\n\t\treturn pressure;\n\t}\n \n}\n \n// There can be multiple displays developer can add as many display as it wants by using DisplayElement Interface\nclass CurrentConditionDisplay implements Observer, DisplayElement {\n\tprivate WeatherData weatherdata;\n \n\tpublic CurrentConditionDisplay(WeatherData weatherdata) {\n\t\tthis.weatherdata = weatherdata;\n\t\tthis.weatherdata.registerObserver(this);\n\t}\n \n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(&quot;Current Condition = &quot; + weatherdata.getHumidity() + &quot; &quot; + weatherdata.getPressure());\n\t}\n \n\t@Override\n\tpublic void update() {\n\t\tthis.display();\n\t}\n \n}\n \n// lets add new display again\nclass ForecastDisplay implements DisplayElement, Observer {\n\tprivate WeatherData weatherdata;\n \n\tpublic ForecastDisplay(WeatherData weatherdata) {\n\t\tthis.weatherdata = weatherdata;\n\t\tthis.weatherdata.registerObserver(this);\n\t}\n \n\t@Override\n\tpublic void display() {\n\t\tSystem.out.println(&quot;Forecast Display = &quot; + weatherdata.getHumidity() * 100 + &quot; &quot; + weatherdata.getPressure());\n\t}\n \n\t@Override\n\tpublic void update() {\n\t\tthis.display();\n\t}\n \n}\n \npublic class ObserverPattern {\n \n\tpublic static void main(String[] args) {\n\t\t// Creating the instance of Weather Class\n\t\tWeatherData weatherdata = new WeatherData();\n \n\t\t// Displaying the data from the Weather Data using Observer or Display\n\t\tCurrentConditionDisplay currcondition = new CurrentConditionDisplay(weatherdata);\n\t\tForecastDisplay forecastdisplay = new ForecastDisplay(weatherdata);\n \n\t\t// Setting the measurements in the weather data\n\t\tweatherdata.setMeasurements(1, 1, 2);\n\t\tweatherdata.setMeasurements(5, 5, 5);\n\t}\n}\nOutput:\n Current Condition = 2.0 1.0\n Forecast Display = 200.0 1.0\n Current Condition = 5.0 5.0\n Forecast Display = 500.0 5.0\n\n\nReal World Example"},"Strategy-Pattern":{"title":"Strategy Pattern","links":["tags/behavioral"],"tags":["behavioral"],"content":"behavioral\nDefinition\nIt defines a family of algorithms, encapsulates each one, and makes them interchangeable. The Strategy Pattern allows algorithms to vary independently from the clients that use them.\n\nReal World Analogy - 1\nConsider creating a Duck application with different types of ducks that can quack and fly. A simple approach would be to create a base class called Duck with methods like fly() and quack(), then implement these methods in specific duck types.\n---\ntitle: Brute Force Approach\n---\nclassDiagram\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        +fly() void\n        +quack() void\n    }\n    class MallardDuck{\n        +fly() void\n        +quack() void\n    }\n    class RubberDuck{\n        +fly() void  \n        +quack() void\n    }\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\n\n\n                  \n                  What is Wrong With These Approach ? \n                  \n                \n\nYou have implemented a base class called Duck, where methods like fly() and quack() are already defined. For example, the base class Duck has a default implementation of flying. However, in the case of a RubberDuck class, the duck cannot quack or fly.\nTo modify this behavior, you would need to override the fly() and quack() methods, which becomes inefficient when dealing with dozens of duck types. To address this issue, you can use the Strategy Pattern.\n\n\nLet’s see the Implementation via Strategy Pattern:\n---\ntitle: Strategy Pattern\n---\n\nclassDiagram\n\n    class FlyBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +fly() void\n    }\n\n    class QuackBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +quack() void\n    }\n\n    class FlyWithWings{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- FlyWithWings\n\n    class NoFly{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- NoFly\n\n    class Quack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- Quack\n\n    class MuteQuack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- MuteQuack\n\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        -flyBehavior : FlyBehavior\n        -quackBehavior : QuackBehavior\n\n        +performFly() void\n        +performQuack() void\n        +setFlyBehavior(fb : FlyBehavior) void\n        +setQuackBehavior(qb : QuackBehavior) void\n    }\n    FlyBehavior *-- Duck : has a\n    QuackBehavior *-- Duck : has a\n\n    class MallardDuck{\n    }\n\n    class RubberDuck{\n    }\n\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\nHere, we create two interfaces:\n\nFlyBehavior, which defines different flying behaviors.\nQuackBehavior, which defines different quacking behaviors.\n\nBy implementing these interfaces, you can create new behaviors independently. The abstract base class Duck uses these interfaces in the constructor, allowing you to dynamically change behaviors or even create a new duck type by passing specific or custom behaviors.\nNow, instead of modifying the base Duck class for every new type, you can simply create new behavior implementations and plug them in—making the system more flexible and scalable!\n\nCode in Java\nBelow is the Code for the above Strategy Pattern we discussed over Here.\n// Strategy Design Pattern Example: Ducks with Flying and Quacking Behaviors\n \npublic interface FlyBehavior {\n  // Interface defining the fly behavior contract\n  void fly();\n}\n \npublic class FlyWithWings implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can Fly&quot;);\n  }\n}\n \npublic class NoFly implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can&#039;t Fly&quot;);\n  }\n}\n \npublic interface QuackBehavior {\n  // Interface defining the quack behavior contract\n  void quack();\n}\n \npublic class Quack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Quacking....&quot;);\n  }\n}\n \npublic class MuteQuack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Mute Quacking&quot;);\n  }\n}\n \npublic class Squeak implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Squeak&quot;);\n  }\n}\n \npublic abstract class Duck {\n \n  private FlyBehavior _flyBehavior;\n  private QuackBehavior _quackBehavior;\n \n  // Constructor taking FlyBehavior and QuackBehavior arguments\n  // This allows for flexible behavior assignment at runtime\n  public Duck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    this._flyBehavior = flybehavior;\n    this._quackBehavior = quackBehavior;\n  }\n \n  public void quack() {\n    this._quackBehavior.quack();\n  }\n \n  public void fly() {\n    this._flyBehavior.fly();\n  }\n}\n \npublic class RubberDuck extends Duck {\n \n  public RubberDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class MallardDuck extends Duck {\n \n  public MallardDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class Index {\n  public static void main(String[] args) {\n    // The duck which is mute and cannot fly lets create that duck using rubber duck\n    System.out.println(&quot;======= Rubber Duck ======&quot;);\n    Duck rubberDuck = new RubberDuck(new NoFly(), new MuteQuack());\n    rubberDuck.fly();\n    rubberDuck.quack();\n \n    System.out.println();\n \n    // Mallard Duck\n    // Making the code feasible here we can change the behavior any time we want\n    // just need to change the constuctor call.\n    System.out.println(&quot;===== Mallard Duck =====&quot;);\n    Duck mallardDuck = new MallardDuck(new FlyWithWings(), new Squeak());\n    mallardDuck.fly();\n    mallardDuck.quack();\n  }\n}\nOutput:\n======= Rubber Duck ======\nCan&#039;t Fly\nMUte Quacking\n\n===== Mallard Duck =====\nCan Fly\nSqueak\n\n\nReal World Analogy - 2\nLet’s take another example: the Logging Framework.\nThis type of pattern is commonly used in logging frameworks, where you only pass the Logger Interface and call the log() method. The rest is handled by the class that implements the interface.\nSuppose an application uses an ILogger interface, which declares methods like LogInfo(), LogError(), and LogDebug(). The logger can have multiple implementations, such as ConsoleLogger, FileLogger, JsonLogger, or DBLogger.\nUsing this approach, there is no need to modify all the methods in the application when changing the type of logger. You only need to switch to a new logger by defining it in the configuration section, while the rest is managed by the respective logging class.\nBelow is the class diagram illustrating this approach.\n---\ntitle: Logger Framework Design\n---\n\nclassDiagram\n\tclass ILogger{\n\t\t&lt;&lt;interface&gt;&gt;\n\t\t+LogInf() void\n\t\t+LogError() void\n\t\t+LogWarning() void\n\t\t+LogDubug() void\n\t}\n\n\tclass FileLogger{\n\t\t+LogInf() void\n\t\t+LogError() void\n\t\t+LogWarning() void\n\t\t+LogDubug() void\n\t}\n\n\tclass ConsoleLogger{\n\t\t+LogInf() void\n\t\t+LogError() void\n\t\t+LogWarning() void\n\t\t+LogDubug() void\n\t}\n\n\tILogger &lt;|-- FileLogger\n\tILogger &lt;|-- ConsoleLogger\n\n\tclass Application{\n\t\t-logger ILogger \n\t\t+PerformOperation() void\n\t\t+KillProcess() void\n\t}\n\n\t\n\n\nReal World Example\nThe Comparator interface acts as the Strategy Pattern. By inheriting this interface, you can create your custom comparator, which allows you to sort collections.\nclass NameComparator implements Comparator&lt;Person&gt; {\n    public int compare(Person p1, Person p2) {\n        return p1.name.compareTo(p2.name);\n    }\n}\n \nList&lt;Person&gt; people = Arrays.asList( \n\tnew Person(&quot;Alice&quot;, 25), \n\tnew Person(&quot;Bob&quot;, 30), \n\tnew Person(&quot;Charlie&quot;, 22) \n);\n \n// Apply sorting strategy at runtime \nCollections.sort(people, new NameComparator()); \nSystem.out.println(&quot;Sorted by name: &quot; + people);\n\nDesign Principles\n\n\n                  \n                  Note \n                  \n                \n\nThe Design Principles will be changing based on the Design Patterns and new design principles will be added to it as you go through the Different Design Patterns.\n\n\n\nEncapsulate What Varies - Identify the parts of the code that are going to change and encapsulate them into separate class just like the Strategy Pattern.\nFavor Composition Over Inheritance - Instead of using inheritance on extending functionality, rather use composition by delegating behavior to other objects.\nProgram to Interface not Implementations - Write code that depends on Abstractions or Interfaces rather than Concrete Classes.\n\n"},"index":{"title":"Design Patterns","links":["tags/","Strategy-Pattern","Observer-Pattern"],"tags":[""],"content":"What is Design Pattern ?\nDesign patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.\nThree Main Patterns\n\nCreational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.\nStructural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.\nBehavioral patterns take care of effective communication and the assignment of responsibilities between objects.\n\n\n\n                  \n                  Prerequisite \n                  \n                \n\nMust have knowledge of OOPS (Object-Oriented Programming Principles) and Java. The design patterns are primarily based on OOPS concepts. The code in this tutorial is mainly written in Java and related frameworks.\nOOPS Concepts:\n\nInheritance\nAbstraction\nPolymorphism\nEncapsulation\n\n\n\nBefore diving into design patterns, it’s important to understand the SOLID Principles, Tightly Coupled Classes, and Loosely Coupled Classes. Additionally, some tips and tricks for writing clean code.\n\nTightly Coupled and Loosely Coupled Classes\nIn software design, coupling refers to the degree of dependency between two classes or modules. It determines how closely one class is connected to another.\n1. Tightly Coupled Classes\nDefinition: These classes are highly dependent on each other. Changes in one class often require changes in the other, making the system rigid and harder to maintain. These classes violates the Single Responsibility Principle which is the part of the SOLID Principle.\nExample :\nConsider a MessageService class that sends messages via Email, SMS, or other techniques. The implementation might look like the following code:\nclass MessageService {\n \n\tpublic static void sendMessage(string message){\n\t\t// Tightly Coupled on the email only\n\t\tEmailClient emailclient = new EmailClient();\n\t\temailclient.sendEmail(message);\n\t}\n\t\n}\nIn this code, you can see that the sendMessage method sends the message exclusively via Email. The EmailClient class is tightly coupled with this method. If you need to send messages using other providers (e.g., SMS or other techniques), you would have to create separate services for each provider. This approach is inefficient and leads to code repetition.\n2. Loosely Coupled Classes\nDefinition: These classes have minimal dependency on each other. They interact through interfaces or abstractions, making the system flexible, maintainable, and reusable.\nThese Approach Follows Dependency Inversion Principle which is again the part of the SOLID Principle.\nExample:\nIn the earlier example, the MessageService class was heavily dependent on EmailClient. In such cases, if you need to create another service, it becomes inefficient. We can avoid this dependency by passing the ProviderClient interface as a parameter to the sendMessage method. Then, we implement the ProviderClient interface for various provider services.\n \n// Interface to be implemented by various provider services\ninterface ProviderClient {\n    void send(String message, String to);\n}\n \n// Email Service implementing the ProviderClient interface\npublic class EmailClient implements ProviderClient {\n    public void send(String message, String to) {\n        // Code to send an email\n    } \n}\n \n// SMS Service implementing the ProviderClient interface\npublic class SMSClient implements ProviderClient {\n    public void send(String message, String to) {\n        // Code to send an SMS\n    }\n}\n \n// MessageService class using ProviderClient\nclass MessageService {\n    public static void sendMessage(ProviderClient client, String message, String to) {\n        client.send(message, to);\n    }\n}\n \nNow, you can add as many providers as needed, and MessageService will continue to work without being tightly coupled to EmailClient.\n\n SOLID Principles\nThe SOLID principles are five key object-oriented design principles that should be followed when creating a class structure. Let’s go through each principle one by one:\n1. Single Responsibility Principle (SRP)\nThis principle states that a class should have only one responsibility and, therefore, only one reason to change.\nExample:\nConsider a Book class that contains all the methods and variables related to a book. You should not include code related to a Student class or methods that are not relevant to the Book class.\n2. Open-Closed Principle (OCP)\nThis principle states that a class should be open for extension but closed for modification. Modification refers to changing the code of an existing class, while extension means adding new functionality without altering the existing code.\nExample:\nIf you have a well-tested and reliable class, modifying its code can introduce bugs and potential system crashes. Instead, you should extend the functionality using abstract classes or interfaces rather than modifying the tested code directly.\n3. Liskov Substitution Principle (LSP)\nThis principle states that subtypes of a base class must be substitutable without altering the correctness of the program.\nExample:\nConsider an abstract or base class Shape with a method to calculate the area. If you create a Rectangle class by inheriting from Shape, calling the area calculation method on a Rectangle object (using a Shape reference) should return the expected result without requiring changes to the base class.\n4. Interface Segregation Principle (ISP)\nThis principle states that a class should not be forced to implement interfaces it does not use. It is better to have multiple smaller, specific interfaces rather than a large, general-purpose interface.\nExample:\nConsider a Programmer class with methods like work(), eat(), test(), and assign(), all declared in an IEmployee interface. The problem arises when you introduce Manager and TeamLead classes—they require the assign() method, but it doesn’t belong in the Programmer class. To fix this, you can segregate the interfaces:\n\nCommon employee methods go in the IEmployee interface.\nManagement-related methods go in an IManage interface.\n\nThis way, only relevant methods are implemented by each class.\n5. Dependency Inversion Principle (DIP)\nThis principle states that high-level modules should not depend on low-level modules; instead, both should depend on abstractions (interfaces or abstract classes).\nExample:\nConsider an SQLManager class that performs CRUD operations. It has an ILogger interface for logging, which allows you to use different loggers like FileLogger, ConsoleLogger, or TableLogger. Since the SQLManager depends on the abstraction (ILogger) rather than a specific logging implementation, you can switch loggers without breaking the system.\n\nContents:\n\nStrategy Pattern\nObserver Pattern\n\n\n\n\n                  \n                  Note\n                  \n                \n\nAll the Patterns and code Examples are taken from the Book titled Head First Design Patterns\n\n"}}