{"Decorator-Pattern":{"title":"Decorator Pattern","links":[],"tags":[],"content":"Comming Soon"},"Observer-Pattern":{"title":"Observer Pattern","links":[],"tags":[],"content":"Comming Soon"},"Strategy-Pattern":{"title":"Strategy Pattern","links":["tags/behavioral"],"tags":["behavioral"],"content":"behavioral\nDefinition\nIt Defines a family of algorithms encapsulates each one, and makes them interchangeable. Strategy Lets the algorithms vary independently from clients that use it.\n\nReal World Analogy - 1\nConsider creating a Duck application with different types of ducks that can quack and fly. A simple approach would be to create a base class called Duck with methods like fly and quack, and then implement these methods in the specific types of ducks.\n---\ntitle: Brute Force Approach\n---\nclassDiagram\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        +fly() void\n        +quack() void\n    }\n    class MallardDuck{\n        +fly() void\n        +quack() void\n    }\n    class RubberDuck{\n        +fly() void  \n        +quack() void\n    }\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\n\n\n                  \n                  What is Wrong With These Approach ? \n                  \n                \n\nYou have implemented a base class called Duck, where methods like fly and quack are already defined. For example, the base class Duck has a default implementation of flying. However, in the case of a RubberDuck class, the duck cannot quack or fly. To modify this behavior, you would need to rewrite the fly and quack methods, which becomes inefficient when dealing with dozens of duck types. To address this issue, you can use the Strategy Pattern.\n\n\nLet’s see the Implementation via Strategy Pattern:\n---\ntitle: Strategy Pattern\n---\n\nclassDiagram\n\n    class FlyBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +fly() void\n    }\n\n    class QuackBehavior{\n        &lt;&lt;interface&gt;&gt;\n        +quack() void\n    }\n\n    class FlyWithWings{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- FlyWithWings\n\n    class NoFly{\n        +fly() void\n    }\n    FlyBehavior &lt;|-- NoFly\n\n    class Quack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- Quack\n\n    class MuteQuack{\n        +quack() void\n    }\n    QuackBehavior &lt;|-- MuteQuack\n\n    class Duck{\n        &lt;&lt;Abstract&gt;&gt;\n        -flyBehavior : FlyBehavior\n        -quackBehavior : QuackBehavior\n\n        +performFly() void\n        +performQuack() void\n        +setFlyBehavior(fb : FlyBehavior) void\n        +setQuackBehavior(qb : QuackBehavior) void\n    }\n    FlyBehavior *-- Duck : has a\n    QuackBehavior *-- Duck : has a\n\n    class MallardDuck{\n    }\n\n    class RubberDuck{\n    }\n\n    Duck &lt;|-- MallardDuck\n    Duck &lt;|-- RubberDuck\n\nHere, we create two interfaces: FlyBehavior and QuackBehavior, which define the methods for flying and quacking. By implementing these interfaces, you can create new behaviors. In the abstract base class Duck, you use these interfaces in the constructor, allowing you to change the behavior dynamically or even implement a new duck type by passing specific behaviors or custom behaviors.\n\nCode in Java\nBelow is the Code for the above Strategy Pattern we discussed over Here.\n// Strategy Design Pattern Example: Ducks with Flying and Quacking Behaviors\n \npublic interface FlyBehavior {\n  // Interface defining the fly behavior contract\n  void fly();\n}\n \npublic class FlyWithWings implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can Fly&quot;);\n  }\n}\n \npublic class NoFly implements FlyBehavior {\n  @Override\n  public void fly() {\n    System.out.println(&quot;Can&#039;t Fly&quot;);\n  }\n}\n \npublic interface QuackBehavior {\n  // Interface defining the quack behavior contract\n  void quack();\n}\n \npublic class Quack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Quacking....&quot;);\n  }\n}\n \npublic class MuteQuack implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Mute Quacking&quot;);\n  }\n}\n \npublic class Squeak implements QuackBehavior {\n  @Override\n  public void quack() {\n    System.out.println(&quot;Squeak&quot;);\n  }\n}\n \npublic abstract class Duck {\n \n  private FlyBehavior _flyBehavior;\n  private QuackBehavior _quackBehavior;\n \n  // Constructor taking FlyBehavior and QuackBehavior arguments\n  // This allows for flexible behavior assignment at runtime\n  public Duck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    this._flyBehavior = flybehavior;\n    this._quackBehavior = quackBehavior;\n  }\n \n  public void quack() {\n    this._quackBehavior.quack();\n  }\n \n  public void fly() {\n    this._flyBehavior.fly();\n  }\n}\n \npublic class RubberDuck extends Duck {\n \n  public RubberDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class MallardDuck extends Duck {\n \n  public MallardDuck(FlyBehavior flybehavior, QuackBehavior quackBehavior) {\n    super(flybehavior, quackBehavior);\n  }\n \n}\n \npublic class Index {\n  public static void main(String[] args) {\n    // The duck which is mute and cannot fly lets create that duck using rubber duck\n    System.out.println(&quot;======= Rubber Duck ======&quot;);\n    Duck rubberDuck = new RubberDuck(new NoFly(), new MuteQuack());\n    rubberDuck.fly();\n    rubberDuck.quack();\n \n    System.out.println();\n \n    // Mallard Duck\n    // Making the code feasible here we can change the behavior any time we want\n    // just need to change the constuctor call.\n    System.out.println(&quot;===== Mallard Duck =====&quot;);\n    Duck mallardDuck = new MallardDuck(new FlyWithWings(), new Squeak());\n    mallardDuck.fly();\n    mallardDuck.quack();\n  }\n}\n\nReal World Analogy - 2\nLet’s take the another Example of the Logging Framework."},"index":{"title":"Design Patterns","links":["Strategy-Pattern","Observer-Pattern"],"tags":[],"content":"What is Design Pattern ?\nDesign patterns are typical solutions to commonly occurring problems in software design. They are like pre-made blueprints that you can customize to solve a recurring design problem in your code.\nThree Main Patterns\n\nCreational patterns provide object creation mechanisms that increase flexibility and reuse of existing code.\nStructural patterns explain how to assemble objects and classes into larger structures, while keeping these structures flexible and efficient.\nBehavioral patterns take care of effective communication and the assignment of responsibilities between objects.\n\n\n\n                  \n                  Prerequisite \n                  \n                \n\nMust have knowledge of OOPS (Object-Oriented Programming Principles) and Java. The design patterns are primarily based on OOPS concepts. The code in this tutorial is mainly written in Java and related frameworks.\nOOPS Concepts:\n\nInheritance\nAbstraction\nPolymorphism\nEncapsulation\n\n\n\nBefore diving into design patterns, it’s important to understand the SOLID Principles, Tightly Coupled Classes, and Loosely Coupled Classes. Additionally, some tips and tricks for writing clean code.\n\nContents:\n\nStrategy Pattern\nObserver Pattern\n\n\n\n\n                  \n                  Note\n                  \n                \n\nAll the Patterns and code Examples are taken from the Book titled Head First Design Patterns\n\n"}}